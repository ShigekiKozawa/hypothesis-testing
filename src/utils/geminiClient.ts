import { GoogleGenerativeAI } from '@google/generative-ai';

const API_KEY = (import.meta as any).env?.VITE_GEMINI_API_KEY;

if (!API_KEY) {
  throw new Error(
    'VITE_GEMINI_API_KEY が設定されていません。\n' +
    '.env.local ファイルを作成して、APIキーを設定してください。'
  );
}

const genAI = new GoogleGenerativeAI(API_KEY);

const API_TIMEOUT = 60000;
const MAX_RETRIES = 3;
const MIN_QUESTION_COUNT = 1;
const MAX_QUESTION_COUNT = 50;

export interface GeneratedQuestion {
  id: number;
  question: string;
  options: string[];
  correct: number;
  explanation: string;
  chartType?: 'scatter' | 'line' | 'bar' | 'histogram' | 'boxplot';
  chartData?: Array<{x: number; y: number} | {name: string; value: number}>;
  barData?: Array<{name: string; value: number}>;
  boxPlotData?: { min: number; q1: number; median: number; q3: number; max: number };
  chartLabels?: {x: string; y: string};
}

export interface QuestionGenerationRequest {
  grade: '3級' | '4級';
  type: 'section' | 'exam';
  section?: string;
  sectionDescription?: string;
  count: number;
}

export class ValidationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ValidationError';
  }
}

export class APIError extends Error {
  constructor(message: string, public statusCode?: number, public retryAfter?: number) {
    super(message);
    this.name = 'APIError';
  }
}

export class RateLimitError extends Error {
  constructor(message: string, public retryAfter: number) {
    super(message);
    this.name = 'RateLimitError';
  }
}

export class TimeoutError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'TimeoutError';
  }
}

function validateRequest(request: QuestionGenerationRequest): void {
  if (!request.grade || (request.grade !== '3級' && request.grade !== '4級')) {
    throw new ValidationError(`無効な級です: ${request.grade}。'3級'または'4級'を指定してください。`);
  }

  if (!request.type || (request.type !== 'section' && request.type !== 'exam')) {
    throw new ValidationError(`無効なタイプです: ${request.type}。'section'または'exam'を指定してください。`);
  }

  if (typeof request.count !== 'number' || !Number.isInteger(request.count)) {
    throw new ValidationError(`問題数は整数である必要があります: ${request.count}`);
  }

  if (request.count < MIN_QUESTION_COUNT || request.count > MAX_QUESTION_COUNT) {
    throw new ValidationError(
      `問題数は${MIN_QUESTION_COUNT}〜${MAX_QUESTION_COUNT}の範囲で指定してください。指定された値: ${request.count}`
    );
  }

  if (request.type === 'section' && !request.section) {
    throw new ValidationError('タイプが"section"の場合、sectionフィールドは必須です。');
  }
}

function validateQuestion(question: any, index: number): GeneratedQuestion {
  if (!question || typeof question !== 'object') {
    throw new ValidationError(`問題${index + 1}が無効なオブジェクトです。`);
  }

  if (typeof question.id !== 'number' || !Number.isInteger(question.id) || question.id < 1) {
    throw new ValidationError(`問題${index + 1}のIDが無効です: ${question.id}`);
  }

  if (typeof question.question !== 'string' || question.question.trim().length === 0) {
    throw new ValidationError(`問題${index + 1}の問題文が無効です。`);
  }

  if (!Array.isArray(question.options) || question.options.length !== 4) {
    throw new ValidationError(`問題${index + 1}の選択肢は4つである必要があります。`);
  }

  for (let i = 0; i < question.options.length; i++) {
    if (typeof question.options[i] !== 'string' || question.options[i].trim().length === 0) {
      throw new ValidationError(`問題${index + 1}の選択肢${i + 1}が無効です。`);
    }
  }

  if (typeof question.correct !== 'number' || !Number.isInteger(question.correct)) {
    throw new ValidationError(`問題${index + 1}の正解番号が無効です: ${question.correct}`);
  }

  if (question.correct < 1 || question.correct > 4) {
    throw new ValidationError(`問題${index + 1}の正解番号は1〜4の範囲である必要があります: ${question.correct}`);
  }

  if (typeof question.explanation !== 'string' || question.explanation.trim().length === 0) {
    throw new ValidationError(`問題${index + 1}の解説が無効です。`);
  }

  return {
    id: question.id,
    question: question.question.trim(),
    options: question.options.map((opt: string) => opt.trim()),
    correct: question.correct,
    explanation: question.explanation.trim(),
  };
}

function sanitizeText(text: string): string {
  return text
    .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
    .replace(/<[^>]*>/g, '')
    .trim();
}

function detectGraphReference(question: string): boolean {
  const graphKeywords = [
    '下のグラフ', '次のグラフ', '以下のグラフ',
    '下の図', '次の図', '以下の図',
    '下の散布図', '次の散布図',
    '下のヒストグラム', '次のヒストグラム',
    '下の箱ひげ図', '次の箱ひげ図',
    '下の折れ線グラフ', '次の折れ線グラフ',
    '下の棒グラフ', '次の棒グラフ'
  ];
  return graphKeywords.some(keyword => question.includes(keyword));
}

function detectGraphType(question: string, options: string[]): 'histogram' | 'boxplot' | 'scatter' | 'line' | 'bar' | null {
  const text = question + ' ' + options.join(' ');
  
  if (text.includes('箱ひげ図') || text.includes('四分位') || text.includes('IQR') || text.includes('Q1') || text.includes('Q3')) {
    return 'boxplot';
  }
  if (text.includes('ヒストグラム') || text.includes('度数分布') || text.includes('階級') || text.includes('最頻値')) {
    return 'histogram';
  }
  if (text.includes('散布図') || text.includes('相関') || text.includes('回帰')) {
    return 'scatter';
  }
  if (text.includes('折れ線') || text.includes('時系列') || text.includes('推移') || text.includes('傾向')) {
    return 'line';
  }
  if (text.includes('棒グラフ') || text.includes('カテゴリー') || text.includes('比較')) {
    return 'bar';
  }
  
  return 'histogram';
}

function generateHistogramData(): { barData: Array<{name: string; value: number}>; chartLabels: {x: string; y: string} } {
  const classCount = 6 + Math.floor(Math.random() * 4);
  const barData = [];
  
  for (let i = 0; i < classCount; i++) {
    const start = i * 10;
    const end = (i + 1) * 10;
    const value = Math.floor(Math.random() * 15) + 5;
    barData.push({
      name: `${start}-${end}`,
      value: value
    });
  }
  
  return {
    barData,
    chartLabels: { x: '階級', y: '度数' }
  };
}

function generateBoxPlotData(): { boxPlotData: { min: number; q1: number; median: number; q3: number; max: number } } {
  const min = 40 + Math.floor(Math.random() * 10);
  const q1 = min + 10 + Math.floor(Math.random() * 10);
  const median = q1 + 8 + Math.floor(Math.random() * 8);
  const q3 = median + 8 + Math.floor(Math.random() * 10);
  const max = q3 + 10 + Math.floor(Math.random() * 15);
  
  return {
    boxPlotData: { min, q1, median, q3, max }
  };
}

function generateScatterData(): { chartData: Array<{x: number; y: number}>; chartLabels: {x: string; y: string} } {
  const pointCount = 6 + Math.floor(Math.random() * 5);
  const chartData = [];
  const slope = 1.5 + Math.random() * 1.5;
  const intercept = 1 + Math.random() * 3;
  
  for (let i = 0; i < pointCount; i++) {
    const x = i + 1;
    const y = slope * x + intercept + (Math.random() - 0.5) * 2;
    chartData.push({ x, y: Math.round(y * 10) / 10 });
  }
  
  return {
    chartData,
    chartLabels: { x: '変数X', y: '変数Y' }
  };
}

function generateLineData(): { chartData: Array<{name: string; value: number}>; chartLabels: {x: string; y: string} } {
  const months = ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月'];
  const pointCount = 5 + Math.floor(Math.random() * 4);
  const chartData = [];
  
  let value = 100 + Math.floor(Math.random() * 50);
  for (let i = 0; i < pointCount; i++) {
    chartData.push({
      name: months[i],
      value: value
    });
    value += Math.floor(Math.random() * 20) - 5;
  }
  
  return {
    chartData,
    chartLabels: { x: '月', y: '値' }
  };
}

function generateBarData(): { barData: Array<{name: string; value: number}>; chartLabels: {x: string; y: string} } {
  const categories = ['A', 'B', 'C', 'D', 'E'];
  const barData = categories.map(cat => ({
    name: cat,
    value: Math.floor(Math.random() * 80) + 20
  }));
  
  return {
    barData,
    chartLabels: { x: 'カテゴリー', y: '値' }
  };
}

function ensureGraphData(question: GeneratedQuestion): void {
  const hasGraphReference = detectGraphReference(question.question);
  
  if (!hasGraphReference) {
    return;
  }
  
  const hasChartType = !!question.chartType;
  const hasChartData = !!(question.chartData || question.barData || question.boxPlotData);
  
  if (hasChartType && hasChartData) {
    console.log(`✅ 問題${question.id}: グラフデータが正しく含まれています (${question.chartType})`);
    return;
  }
  
  console.warn(`⚠️ 問題${question.id}: グラフ参照があるのにデータがありません。自動生成します。`);
  
  let detectedType = question.chartType || detectGraphType(question.question, question.options);
  
  if (!detectedType) {
    detectedType = 'histogram';
  }
  
  question.chartType = detectedType;
  
  switch (detectedType) {
    case 'histogram': {
      const data = generateHistogramData();
      question.barData = data.barData;
      question.chartLabels = data.chartLabels;
      console.log(`✅ 問題${question.id}: ヒストグラムデータを自動生成しました`);
      break;
    }
    case 'boxplot': {
      const data = generateBoxPlotData();
      question.boxPlotData = data.boxPlotData;
      console.log(`✅ 問題${question.id}: 箱ひげ図データを自動生成しました`);
      break;
    }
    case 'scatter': {
      const data = generateScatterData();
      question.chartData = data.chartData;
      question.chartLabels = data.chartLabels;
      console.log(`✅ 問題${question.id}: 散布図データを自動生成しました`);
      break;
    }
    case 'line': {
      const data = generateLineData();
      question.chartData = data.chartData;
      question.chartLabels = data.chartLabels;
      console.log(`✅ 問題${question.id}: 折れ線グラフデータを自動生成しました`);
      break;
    }
    case 'bar': {
      const data = generateBarData();
      question.barData = data.barData;
      question.chartLabels = data.chartLabels;
      console.log(`✅ 問題${question.id}: 棒グラフデータを自動生成しました`);
      break;
    }
  }
}

async function withTimeout<T>(promise: Promise<T>, timeoutMs: number): Promise<T> {
  let timeoutHandle: number | undefined;
  
  const timeoutPromise = new Promise<never>((_, reject) => {
    timeoutHandle = window.setTimeout(() => {
      reject(new TimeoutError(`処理が${timeoutMs / 1000}秒でタイムアウトしました。`));
    }, timeoutMs);
  });

  try {
    const result = await Promise.race([promise, timeoutPromise]);
    if (timeoutHandle !== undefined) {
      window.clearTimeout(timeoutHandle);
    }
    return result;
  } catch (error) {
    if (timeoutHandle !== undefined) {
      window.clearTimeout(timeoutHandle);
    }
    throw error;
  }
}

async function retryWithBackoff<T>(
  fn: () => Promise<T>,
  retries: number = MAX_RETRIES,
  delay: number = 1000
): Promise<T> {
  try {
    return await fn();
  } catch (error) {
    if (retries <= 0) {
      throw error;
    }

    if (error instanceof ValidationError) {
      throw error;
    }

    if (error instanceof RateLimitError) {
      const waitTime = error.retryAfter || delay;
      console.warn(`レート制限エラー。${waitTime}ms後にリトライします... 残り${retries}回`);
      await new Promise(resolve => setTimeout(resolve, waitTime));
      return retryWithBackoff(fn, retries - 1, Math.max(waitTime * 2, delay * 2));
    }

    console.warn(`リトライします... 残り${retries}回 (${delay}ms待機)`);
    await new Promise(resolve => setTimeout(resolve, delay));
    return retryWithBackoff(fn, retries - 1, delay * 2);
  }
}

const sectionPrompts: Record<string, { grade3?: string; grade4?: string }> = {
  'セクション1: データの種類と基本グラフ': {
    grade3: `
【出題の背景と目的】
データ分析の第一歩として、データの性質を正しく理解し、適切な可視化手法を選択できることが重要です。このセクションでは、データの尺度水準と可視化手法の関係を深く理解しているかを評価します。

【詳細な出題内容】
1. データの種類の識別
   - 量的変数（連続変数：身長、体重、時間など / 離散変数：人数、回数など）と質的変数（名義尺度：血液型、性別 / 順序尺度：満足度、成績）の違い
   - 各データタイプに対する適切な統計処理の判断
   - 実際のデータ例から変数の種類を正しく分類する能力

2. グラフの特性と選択基準
   - 棒グラフ：カテゴリー別の量を比較する際に使用。縦軸はゼロから開始する原則
   - 円グラフ：全体に対する各カテゴリーの割合を示す。合計が100%となるデータに適用
   - 折れ線グラフ：時系列データや連続的な変化を表現。点と点を結ぶことで傾向を視覚化
   - 各グラフの使用が不適切なケース（例：時系列でないデータに折れ線グラフを使用）

3. グラフの読解と作成
   - 軸のラベル、単位、目盛りの適切な設定
   - グラフから読み取れる情報と読み取れない情報の区別
   - 誤解を招くグラフの特徴（例：縦軸がゼロから始まらない、不適切な縮尺）

【問題の具体例】
例1：「あるクラスの生徒30人について、好きなスポーツ（サッカー、野球、バスケットボール）を調査した。このデータを可視化する際、最も適切なグラフはどれか？」
→ このような実践的なシナリオベースの問題

例2：「折れ線グラフが適しているデータはどれか。(1)各都道府県の人口 (2)月ごとの気温の変化 (3)血液型の割合 (4)アンケートの満足度」
→ データタイプとグラフの対応を問う問題`,

    grade4: `
【出題の背景と目的】
データを正しく分類し、適切な方法で可視化することは、データ分析の基礎となります。このセクションでは、身近なデータを正しく扱えるかを評価します。

【詳細な出題内容】
1. 量的データと質的データの違い
   - 量的データ：数値で測定でき、計算（足し算、平均など）が意味を持つデータ
     具体例：身長、体重、テストの点数、気温、売上金額
   - 質的データ：カテゴリーや種類を表すデータ。数値で表されても計算は意味を持たない
     具体例：性別、血液型、色、好きな食べ物、住んでいる地域

2. データの種類に応じたグラフの選択
   - 棒グラフ：カテゴリー別の個数や量を比較（例：各月の売上、科目別のテスト結果）
   - 円グラフ：全体に対する各部分の割合（例：予算の内訳、時間の使い方）
   - 折れ線グラフ：時間的な変化や推移（例：気温の変化、人口の推移）

3. グラフからの情報読み取り
   - グラフのタイトル、軸のラベル、凡例の確認
   - 最大値・最小値の読み取り
   - 変化の傾向（増加・減少）の把握
   - グラフから読み取れること・読み取れないことの区別

【問題の具体例】
例1：「次のうち、量的データはどれか。(1)好きな色 (2)テストの点数 (3)血液型 (4)出身地」
→ 基本的な識別問題

例2：「1年間の月別売上を表すのに最も適したグラフはどれか。(1)円グラフ (2)棒グラフ (3)折れ線グラフ (4)どれでもよい」
→ データの性質とグラフの対応を問う問題

例3：「円グラフを使うのが最も適切なのはどのデータか。(1)各月の気温 (2)クラスの血液型の割合 (3)1週間の体重の変化 (4)テストの点数分布」
→ グラフの特性理解を問う問題`
  },
  'セクション1: データの種類とグラフ': {
    grade4: `量的データと質的データの識別、データの種類に応じた適切なグラフの選択（棒グラフ、円グラフ、折れ線グラフ）、グラフからの情報読み取り`
  },
  'セクション2: 記述統計量の基礎': {
    grade3: `
【出題の背景と目的】
データの中心傾向を表す代表値は、データの特徴を一つの数値で要約する重要な指標です。このセクションでは、各代表値の計算方法だけでなく、どの場面でどの代表値を使うべきかを判断できる実践的な能力を評価します。

【詳細な出題内容】
1. 平均値（算術平均）
   - 計算方法：全データの合計 ÷ データ数
   - 特徴：全データを考慮するが、外れ値の影響を受けやすい
   - 適用場面：データが正規分布に近く、極端な値がない場合
   - 具体例：テストの平均点（60, 70, 80, 90, 100）→ 80点

2. 中央値（メジアン）
   - 計算方法：データを小さい順に並べて真ん中の値（データ数が偶数の場合は中央2つの平均）
   - 特徴：外れ値の影響を受けにくい、順序尺度にも適用可能
   - 適用場面：所得分布など、極端な値がある場合
   - 具体例：年収（300, 400, 500, 600, 10000万円）→ 中央値500万円（平均2360万円より適切）

3. 最頻値（モード）
   - 計算方法：最も頻繁に出現する値
   - 特徴：名義尺度にも適用可能、複数存在する場合あり
   - 適用場面：カテゴリーデータ、離散データ
   - 具体例：靴のサイズで最も売れるサイズを知りたい場合

4. 偏差値の計算と解釈
   - 計算式：偏差値 = 50 + 10 × (個人の得点 - 平均点) / 標準偏差
   - 意味：平均を50、標準偏差を10に標準化した値
   - 活用：異なるテスト間の成績比較、相対的な位置の把握
   - 具体例：平均60点、標準偏差10点のテストで70点を取った場合 → 偏差値60

【問題の具体例】
例1：「データ{10, 20, 30, 40, 1000}について、データの中心を表すのに最も適切な代表値はどれか。理由も含めて答えよ」
→ 外れ値がある場合の代表値の選択

例2：「平均点70点、標準偏差5点のテストで80点を取った生徒の偏差値はいくらか」
→ 偏差値の計算問題

例3：「好きな色を調査したデータ（赤15人、青10人、黄5人、緑20人）の代表値として適切なものはどれか」
→ 質的データに対する代表値の選択`,
  },
  'セクション2: 度数分布表と代表値': {
    grade4: `
【出題の背景と目的】
多くのデータを整理し、その特徴を把握するための基本的な手法を理解しているかを評価します。度数分布表の作成から代表値の計算まで、データ整理の基礎を身につけます。

【詳細な出題内容】
1. 度数分布表の作成
   - 階級の設定：データの範囲を適切な幅で区切る（通常5〜15階級）
   - 階級幅：(最大値 - 最小値) / 階級数
   - 度数の数え上げ：各階級に含まれるデータ数を数える
   - 具体例：テストの点数（0〜100点）を10点刻みで集計

2. 度数分布表の読み取り
   - 各階級の度数（データの個数）の確認
   - 最も度数が多い階級（最頻階級）の特定
   - 度数の合計 = 全データ数の確認
   - グラフ（ヒストグラム）との対応

3. 平均値・中央値・最頻値の計算
   - 平均値：全データの合計 ÷ データ数
     例：{60, 70, 80, 90, 100}の平均 = (60+70+80+90+100)/5 = 80
   
   - 中央値：データを順に並べたときの真ん中の値
     例：{60, 70, 80, 90, 100}の中央値 = 80
     例：{60, 70, 80, 90}の中央値 = (70+80)/2 = 75
   
   - 最頻値：最も多く出現する値
     例：{60, 70, 70, 80, 90}の最頻値 = 70

4. 度数分布表からの代表値の推定
   - 階級値：各階級の中央の値（階級の下限+上限）/2
   - 平均値の推定：(階級値 × 度数)の合計 / 全度数
   - 中央値の推定：累積度数が全体の半分を超える階級

【問題の具体例】
例1：「次のデータを10点刻みの階級で度数分布表を作成せよ：{52, 68, 73, 81, 65, 77, 90, 58, 74, 82}」
→ 度数分布表の作成問題

例2：「データ{3, 5, 5, 7, 9, 11}の平均値、中央値、最頻値を求めよ」
→ 3つの代表値の計算

例3：「次の度数分布表から、データの中心傾向について述べよ」
→ 度数分布表の読解問題`
  },
  'セクション3: 散らばりの指標': {
    grade3: `範囲・四分位範囲の計算、標準偏差・分散の計算と解釈、変動係数の計算と意味、散らばりの指標の使い分けを問う問題`
  },
  'セクション3: 度数分布表の応用': {
    grade4: `累積度数・累積相対度数の計算と読み取り、相対度数の計算と意味、階級値を用いた平均値の計算、度数分布表の応用的な読解`
  },
  'セクション4: 箱ひげ図とヒストグラム': {
    grade3: `5数要約（最小値、Q1、中央値、Q3、最大値）の計算、箱ひげ図の作成と読み取り、ヒストグラムの読み取り、度数分布表との対応関係`
  },
  'セクション4: グラフの読解': {
    grade4: `棒グラフ・円グラフ・折れ線グラフ・ヒストグラムの読み取り、グラフ間の比較、グラフから読み取れる情報と読み取れない情報の区別`
  },
  'セクション5: 散布図と相関': {
    grade3: `
【出題の背景と目的】
2つの変数の関係性を視覚的に把握し、数値で定量化することは、データ分析の重要なスキルです。このセクションでは、相関の概念を正しく理解し、因果関係と混同しない批判的思考力を評価します。

【詳細な出題内容】
1. 散布図の作成と読み取り
   - 横軸（x軸）に説明変数、縦軸（y軸）に目的変数をプロット
   - 散布図のパターン認識
     ・正の相関：右上がりの傾向（一方が増えるともう一方も増える）
     ・負の相関：右下がりの傾向（一方が増えるともう一方は減る）
     ・無相関：明確な傾向が見られない
   - 外れ値の識別と影響の評価
   - 具体例：身長と体重（正の相関）、気温とコート売上（負の相関）

2. 相関係数の計算と解釈
   - 相関係数r の範囲：-1 ≤ r ≤ 1
   - 相関係数の意味
     ・r = 1：完全な正の相関（直線上に並ぶ）
     ・r = 0：無相関
     ・r = -1：完全な負の相関
     ・|r| > 0.7：強い相関、0.4 < |r| < 0.7：中程度の相関、|r| < 0.4：弱い相関
   - 計算式：r = (共分散) / (xの標準偏差 × yの標準偏差)
   - 具体例：勉強時間と成績（r = 0.6程度の正の相関）

3. 相関と因果関係の違い
   - 相関関係：2つの変数に関連性がある
   - 因果関係：一方が原因で他方が結果
   - 相関≠因果の重要性：相関があっても因果とは限らない
   - 第三の変数による疑似相関の例
     例：アイスクリームの売上と水難事故（実は気温という第三の変数が原因）
     例：コウノトリの数と出生率（実は都市化・人口という第三の変数）

4. 疑似相関の理解と注意点
   - 偶然の相関：たまたま関連しているように見える
   - 交絡因子：隠れた第三の変数の存在
   - データ解釈における批判的思考の重要性
   - 実験計画による因果関係の検証方法

【問題の具体例】
例1：「ある地域でアイスクリームの売上と水難事故の件数に強い正の相関が見られた。これは因果関係と言えるか？理由も含めて答えよ」
→ 疑似相関の理解

例2：「相関係数が r = -0.85 である2つの変数の関係を説明せよ」
→ 相関係数の解釈

例3：「勉強時間と成績、気温とコート売上、身長と誕生月について、それぞれ相関があると考えられるか」
→ 相関の有無の判断`
  },
  'セクション5: 確率': {
    grade4: `
【出題の背景と目的】
確率は日常生活の様々な場面で使われる重要な概念です。このセクションでは、基本的な確率計算から、場合の数の数え方、独立事象の理解まで、確率的思考の基礎を評価します。

【詳細な出題内容】
1. 確率の基本計算
   - 確率の定義：確率 = (ある事象が起こる場合の数) / (すべての場合の数)
   - サイコロの例
     ・1の目が出る確率 = 1/6
     ・偶数の目が出る確率 = 3/6 = 1/2
     ・4以上の目が出る確率 = 3/6 = 1/2
   
   - コインの例
     ・表が出る確率 = 1/2
     ・2回投げて両方表の確率 = 1/2 × 1/2 = 1/4
   
   - くじ引きの例
     ・10本中3本当たりの場合、当たる確率 = 3/10

2. 場合の数の数え方
   - 樹形図を使った数え上げ
     例：コインを2回投げる → 表表、表裏、裏表、裏裏の4通り
   
   - 掛け算の原理
     例：シャツ3種類×ズボン2種類 = 6通りの組み合わせ
   
   - 順列の基礎（並べ方）
     例：A, B, C の3人の並べ方 = 3×2×1 = 6通り
   
   - 組合せの基礎（選び方）
     例：5人から2人選ぶ = 10通り

3. 独立事象の確率
   - 独立事象：一方の結果が他方に影響しない
     例：サイコロを2回振る、異なるコインを投げる
   
   - 独立事象の確率の乗法定理
     P(A かつ B) = P(A) × P(B)
     例：サイコロで1が出て(1/6)、コインで表が出る(1/2) → 1/6 × 1/2 = 1/12
   
   - 非独立事象との違い
     例：カードを戻さずに引く場合

4. 確率の加法定理
   - 排反事象（同時に起こらない）：P(A または B) = P(A) + P(B)
     例：サイコロで1または2が出る確率 = 1/6 + 1/6 = 1/3
   
   - 余事象の利用：P(A) = 1 - P(Aでない)
     例：少なくとも1回表が出る確率 = 1 - (全部裏の確率)

【問題の具体例】
例1：「サイコロを2回振って、両方とも3以上の目が出る確率を求めよ」
→ 独立事象の乗法定理

例2：「10本のくじの中に当たりが2本ある。2本引いて（戻さない）、少なくとも1本当たる確率を求めよ」
→ 余事象の利用

例3：「赤玉3個、白玉2個が入った袋から2個同時に取り出すとき、2個とも赤玉である確率を求めよ」
→ 組合せと確率`
  },
  'セクション6: クロス集計表': {
    grade3: `クロス集計表の作成と読み取り、行パーセント・列パーセントの計算、条件付き確率の計算、2変数の関係性の分析`
  },
  'セクション6: 散布図と相関': {
    grade4: `散布図の読み取り、正の相関・負の相関・無相関の識別、相関の強さの判断、散布図から読み取れる傾向`
  },
  'セクション7: 確率の基礎': {
    grade3: `確率の計算（条件付き確率を含む）、期待値の計算と意味、確率分布の基礎、樹形図を用いた確率計算`
  },
  'セクション7: 箱ひげ図': {
    grade4: `箱ひげ図の構成要素（最小値、Q1、中央値、Q3、最大値）、5数要約の理解、四分位範囲の計算、箱ひげ図からデータの分布を読み取る`
  },
  'セクション8: 時系列データと指数': {
    grade3: `時系列グラフの読み取り、変化率（増加率・減少率）の計算、指数（基準年を100とする）の計算と解釈、対前年比の計算`
  },
  'セクション8: ヒストグラム': {
    grade4: `ヒストグラムの作成と読み取り、階級と度数の関係、分布の形状（左右対称・右に歪み・左に歪み）の理解、ヒストグラムと度数分布表の対応`
  },
  'セクション9: 標本調査と実験計画': {
    grade3: `
【出題の背景と目的】
母集団全体を調査することは多くの場合不可能なため、標本から母集団を推測する手法が重要です。また、因果関係を明らかにするには適切な実験計画が必要です。このセクションでは、統計的推測の基礎と科学的な実験手法を評価します。

【詳細な出題内容】
1. 母集団と標本の概念
   - 母集団：調査対象の全体集合
     例：日本の全有権者、ある工場で生産される全製品
   - 標本：母集団から抽出された一部
     例：1000人の有権者、100個の製品サンプル
   - 標本調査の目的：標本から母集団の特性を推測
   - 全数調査vs標本調査の比較
     ・全数調査：正確だが時間・費用がかかる（例：国勢調査）
     ・標本調査：迅速・経済的だが推測誤差がある（例：世論調査）

2. 標本抽出法
   - 無作為抽出（ランダムサンプリング）
     ・原理：母集団の各要素が等しい確率で選ばれる
     ・方法：乱数表、くじ引き、コンピュータによる乱数生成
     ・重要性：偏りのない推測が可能
   
   - 層別抽出（Stratified Sampling）
     ・母集団を層（グループ）に分けて、各層から無作為抽出
     ・例：年齢層別、地域別に分けて抽出
     ・利点：各層の特性を反映でき、精度が向上
   
   - 系統抽出（Systematic Sampling）
     ・一定間隔で抽出（例：10人ごとに1人選ぶ）
     ・利点：実施が簡単
     ・注意：周期性がある場合は偏りが生じる可能性

3. 実験デザインの基本
   - 対照群と実験群
     ・対照群：処理を受けないグループ（比較の基準）
     ・実験群：処理を受けるグループ
     ・例：新薬の効果検証（対照群：既存薬または偽薬、実験群：新薬）
   
   - 無作為化（Randomization）
     ・被験者を無作為に群に割り当てる
     ・目的：既知・未知の交絡因子の影響を均等化
   
   - ブラインド法
     ・単盲検：被験者が割り当てを知らない
     ・二重盲検：被験者も研究者も知らない
     ・目的：プラセボ効果や評価者バイアスの除去

4. バイアスとその回避方法
   - 選択バイアス：標本抽出の過程で生じる偏り
     例：電話調査（固定電話を持たない層が除外される）
   
   - 測定バイアス：データ収集過程での偏り
     例：誘導的な質問、観察者の主観
   
   - 非回答バイアス：回答しない人に偏りがある
     例：忙しい人、関心のない人が回答しない
   
   - 回避方法：適切な抽出法、標準化された測定、追跡調査

【問題の具体例】
例1：「ある市の住民10万人の平均所得を調査したい。全員を調査するのは困難なため、1000人を抽出して調査する。この場合、母集団と標本はそれぞれ何か」
→ 母集団と標本の識別

例2：「新しい学習方法の効果を検証するため、クラスを2つのグループに分けた。グループAは新しい方法、グループBは従来の方法で学習させた。この実験の問題点を指摘し、改善方法を提案せよ」
→ 実験デザインの評価と改善

例3：「インターネット調査で『あなたはスマートフォンを使っていますか？』と質問した結果、99%が『はい』と回答した。この結果から『国民の99%がスマートフォンを使っている』と結論できるか」
→ 標本抽出バイアスの理解`,
  },
  'セクション9: 標本調査': {
    grade4: `
【出題の背景と目的】
すべてのデータを調査することは現実的でないため、一部のデータから全体を推測する標本調査の基礎を理解することが重要です。このセクションでは、標本調査の基本概念とその注意点を評価します。

【詳細な出題内容】
1. 母集団と標本の概念
   - 母集団：知りたい対象の全体
     例：日本の全中学生、ある池の全ての魚、工場で作られる全製品
   
   - 標本：母集団から選ばれた一部
     例：1000人の中学生、50匹の魚、100個の製品
   
   - 標本を使う理由
     ・時間と費用の節約
     ・破壊検査の場合（全部調べると製品がなくなる）
     ・調査が不可能な場合（例：宇宙の星の数）

2. 無作為抽出の重要性
   - 無作為抽出（ランダムサンプリング）：母集団のどの要素も等しい確率で選ばれる
     方法：くじ引き、乱数表、コンピュータの乱数
   
   - なぜ無作為抽出が重要か
     ・偏りがない標本が得られる
     ・統計的な推測が可能になる
     ・特定のグループに偏らない
   
   - 具体例：クラス全員から10人選ぶとき
     ○ くじ引きで選ぶ
     × 出席番号の前から10人（偏りがある）
     × 手を挙げた人から10人（偏りがある）

3. 標本調査のバイアス（偏り）
   - バイアスとは：標本が母集団を正しく代表していない状態
   
   - よくあるバイアスの例
     ・街頭調査：通行人だけが対象（家にいる人は含まれない）
     ・電話調査：電話に出やすい人に偏る
     ・ネット調査：ネット利用者に偏る
     ・ボランティアバイアス：自発的に参加する人は特定の意見を持ちやすい
   
   - バイアスの影響：間違った結論を導く可能性

4. 全数調査と標本調査の違い
   - 全数調査（悉皆調査）
     ・母集団全体を調査
     ・例：国勢調査、学校の定期試験
     ・利点：正確
     ・欠点：時間と費用がかかる、破壊検査では不可能
   
   - 標本調査
     ・一部だけを調査
     ・例：視聴率調査、世論調査
     ・利点：迅速、経済的
     ・欠点：推測誤差がある
   
   - 適切な標本サイズ
     ・大きすぎると：費用と時間がかかる
     ・小さすぎると：推測の精度が低い
     ・バランスが重要

【問題の具体例】
例1：「学校全体の給食の人気メニューを調べたい。どのような方法で標本を選ぶのが適切か」
→ 無作為抽出の方法

例2：「ある商品の満足度調査を購入者全員にアンケートを送ったところ、回答率が20%だった。この結果は信頼できるか」
→ 非回答バイアスの理解

例3：「池に魚が何匹いるか調べたい。100匹捕まえて印をつけて戻し、再び100匹捕まえたら印のついた魚が10匹いた。池には約何匹の魚がいると推定できるか」
→ 標本調査の応用（標識再捕法）`,
  },
  'セクション10: 推測統計の入口': {
    grade3: `
【出題の背景と目的】
記述統計（データの要約）から推測統計（母集団の推測）へ。標本データから母集団について科学的に推論する方法を理解しているかを評価します。統計学の最も重要な概念が集約されているセクションです。

【詳細な出題内容】
1. 標本分布の概念
   - 標本平均の分布：同じ母集団から何度も標本を取ったとき、標本平均はどう分布するか
   - 標本平均の期待値 = 母平均（不偏性）
   - 標本平均の標準偏差（標準誤差）= 母標準偏差 / √n
   - 具体例：サイコロを10回振った平均は3.5付近に集まるが、ばらつきがある

2. 中心極限定理
   - 内容：標本サイズnが大きくなると、母集団の分布に関わらず、標本平均の分布は正規分布に近づく
   - 重要性：母集団が正規分布でなくても、標本平均については正規分布を仮定できる
   - 実用上の目安：n ≥ 30 で近似的に正規分布
   - 具体例：サイコロの目（一様分布）でも、多数回の平均は正規分布に従う
   - 応用：世論調査、品質管理など

3. 信頼区間の概念と解釈
   - 点推定：標本平均を母平均の推定値とする（1つの値）
   - 区間推定：母平均が含まれる範囲を確率的に示す（範囲）
   
   - 95%信頼区間の意味
     ・「母平均がこの区間に95%の確率で含まれる」ではない（× よくある誤解）
     ・「同じ方法で100回標本を取れば、約95回はこの区間に母平均が含まれる」（○ 正しい解釈）
   
   - 計算方法：標本平均 ± 1.96 × 標準誤差（95%信頼区間の場合）
   - 区間の幅の意味：狭いほど推定の精度が高い
   - 標本サイズの影響：nが大きいほど区間は狭くなる
   
   - 具体例：世論調査で「支持率52%、誤差±3%」
     → 真の支持率は49%〜55%の範囲にあると考えられる

4. 仮説検定の基礎
   - 基本的な流れ
     ①仮説を立てる：帰無仮説H₀と対立仮説H₁
     ②有意水準αを設定（通常5%や1%）
     ③データを収集し、検定統計量を計算
     ④p値を求める
     ⑤p値<αなら帰無仮説を棄却
   
   - 帰無仮説（H₀）：「効果がない」「差がない」という仮説
     例：「新薬は既存薬と効果が同じ」
   
   - 対立仮説（H₁）：「効果がある」「差がある」という仮説
     例：「新薬は既存薬より効果がある」
   
   - p値：帰無仮説が正しいと仮定したとき、観測されたデータ（またはそれ以上極端なデータ）が得られる確率
     ・p値が小さい（例：< 0.05）→ 帰無仮説は疑わしい → 棄却
     ・p値が大きい → 帰無仮説を棄却できない
   
   - 有意水準（α）：「帰無仮説が正しいのに棄却してしまう」誤りを許容する確率
     通常5%（0.05）または1%（0.01）
   
   - 第一種の過誤（α）：帰無仮説が正しいのに棄却する（「ないものをある」と言う）
   - 第二種の過誤（β）：帰無仮説が誤りなのに棄却しない（「あるものをない」と言う）
   
   - 具体例：「この薬は効果がある」を検証
     H₀：薬は効果がない
     H₁：薬は効果がある
     実験→p値=0.02→p<0.05→H₀を棄却→薬は効果があると結論

【問題の具体例】
例1：「標本サイズを4倍にすると、標本平均の標準誤差はどうなるか」
→ 標準誤差の性質

例2：「95%信頼区間が[48, 52]であるとき、この解釈として適切なものはどれか」
→ 信頼区間の正しい解釈

例3：「新しい教育方法の効果を検証する実験で、p値=0.08が得られた（有意水準5%）。この結果をどう解釈するか」
→ 仮説検定の判断と解釈`,
  },
  'セクション10: データ収集と調査計画': {
    grade4: `
【出題の背景と目的】
データ分析の前段階として、適切にデータを収集することが重要です。このセクションでは、調査の設計から実施、データ整理までの基本的な流れを理解しているかを評価します。

【詳細な出題内容】
1. アンケートの設計方法
   - アンケートの目的を明確にする
     ・何を知りたいのか
     ・誰に聞くのか
     ・どう活用するのか
   
   - 良い質問の条件
     ○ 明確で分かりやすい（専門用語を避ける）
     ○ 一つの質問で一つのことを聞く
     ○ 誘導的でない（特定の答えに誘導しない）
     ○ 答えやすい（選択肢を用意する）
   
   - 悪い質問の例
     × 「あなたは健康的で美味しい野菜が好きですか？」（2つの質問）
     × 「環境に優しいエコ商品を使うべきだと思いませんか？」（誘導的）
     × 「昨年何回映画館に行きましたか？」（覚えていない）
   
   - 良い質問の例
     ○ 「野菜は好きですか？」（はい/いいえ）
     ○ 「映画館には月に何回程度行きますか？」（0回/1回/2〜3回/4回以上）

2. 質問項目の選定
   - 必要な情報を漏れなく集める
   - 不要な質問は省く（回答者の負担を減らす）
   - 個人情報の取り扱いに注意
   - 質問の順序を工夫（簡単な質問から始める）

3. 調査の計画と実施
   - 調査方法の選択
     ・質問紙調査：多数の人に配布できる
     ・面接調査：詳しい情報が得られる
     ・観察調査：実際の行動を記録
     ・実験：条件を変えて比較
   
   - 調査の実施手順
     ①目的の明確化
     ②調査方法の選択
     ③質問項目の作成
     ④予備調査（テスト）
     ⑤本調査の実施
     ⑥データの整理と分析
   
   - 注意点
     ・プライバシーの保護
     ・回答の任意性（強制しない）
     ・データの適切な管理

4. データの整理方法
   - 数値データの整理
     ・度数分布表を作る
     ・グラフで可視化する
     ・代表値を計算する
   
   - カテゴリーデータの整理
     ・分類して集計する
     ・割合を計算する
     ・円グラフや棒グラフで表す
   
   - データのチェック
     ・異常値（おかしな値）がないか
     ・未記入がないか
     ・矛盾がないか

5. 観察研究と実験研究の違い
   - 観察研究：自然な状態を観察
     例：喫煙者と非喫煙者の健康状態を比較
     利点：倫理的問題が少ない、実際の状況を反映
     欠点：因果関係の証明が難しい
   
   - 実験研究：条件を操作して比較
     例：薬を投与する群としない群を比較
     利点：因果関係を明確にできる
     欠点：倫理的配慮が必要、費用がかかる

【問題の具体例】
例1：「次の質問の中で、アンケートとして適切でないものはどれか」
(1)好きな色は何ですか？
(2)健康的で美味しい食事は重要だと思いませんか？
(3)1日に何時間テレビを見ますか？
(4)朝食を毎日食べますか？
→ 誘導的な質問の識別

例2：「クラスで好きな給食メニューを調査したい。どのような方法が適切か」
→ 調査方法の選択

例3：「運動と成績の関係を調べるとき、観察研究と実験研究ではどちらが適切か。理由も含めて答えよ」
→ 研究方法の選択と理由`
  }
};

export async function generateQuestions(
  request: QuestionGenerationRequest
): Promise<GeneratedQuestion[]> {
  const model = genAI.getGenerativeModel({ model: 'gemini-2.5-flash' });

  const grade4Topics = `
【4級の出題範囲】
- データの種類（量的データ、質的データ）
- 度数分布表（相対度数、累積度数、階級値）
- グラフの読み取り（ヒストグラム、箱ひげ図、円グラフ、帯グラフ、散布図、幹葉図、ドットプロット）
- 代表値（平均値、中央値、最頻値）
- 散らばりの指標（範囲、四分位範囲、分散、標準偏差）
- 偏差値の計算
- 確率の基本（独立事象、条件付き確率）
- 割合・比率の計算
- クロス集計表の読み取り
- 標本調査（母集団、標本、無作為抽出）
- 実験計画の基礎（対照群、実験群）
- 時系列データの読み取り`;

  const grade3Topics = `
【3級の出題範囲】
- 標準偏差、分散、変動係数
- 相関係数、共分散、散布図
- 回帰分析（回帰式、決定係数、残差）
- 確率分布（二項分布、正規分布の基本）
- 標本分布、中心極限定理
- 信頼区間の概念と計算
- 仮説検定（帰無仮説、対立仮説、p値、有意水準）
- t検定、F検定、カイ二乗検定の基本
- 第一種・第二種の過誤
- 実験計画（無作為化、ブロック化）
- 標本調査（層別抽出、系統抽出）
- 多重比較の概念
- ノンパラメトリック検定の基本`;

  let prompt = '';

  if (request.type === 'section') {
    const sectionKey = request.section || '';
    const gradeKey = request.grade === '3級' ? 'grade3' : 'grade4';
    const detailedPrompt = sectionPrompts[sectionKey]?.[gradeKey] || request.sectionDescription;

    prompt = `# 役割定義
あなたは日本統計学会が主催する「統計検定」の問題作成を20年以上担当している専門家です。
統計学の深い知識と、学習者の理解度に合わせた適切な問題設計の経験を持っています。
今回、${request.grade}レベルの学習者向けに、教育効果の高い練習問題を作成する任務を担っています。

# あなたの責務
- 学習者が統計的思考力を身につけられる良質な問題を作成すること
- 実際の統計検定の出題傾向と難易度を正確に反映すること
- 誤答選択肢からも学べる、教育的配慮のある問題設計をすること
- 実務で役立つ実践的な問題設定を心がけること

# 作成する問題の条件
- 対象級: ${request.grade}
- 出題範囲: ${request.section}
- 問題数: ${request.count}問

# 出題内容の詳細指定
${detailedPrompt}

# 良い問題の例（参考にすべきパターン）
【例1：計算問題（適切）】
問題文: 「あるクラス5人のテストの点数は {60, 70, 80, 85, 85} である。この平均値と中央値を求めよ。」
選択肢:
1. 平均値76、中央値80
2. 平均値80、中央値80 ✓（正解）
3. 平均値80、中央値85
4. 平均値76、中央値85
解説: 「平均値 = (60+70+80+85+85)/5 = 380/5 = 76... ではなく、正しくは (60+70+80+85+85)/5 = 380/5 = 76。あれ、計算を確認すると... 正しくは380/5 = 76です。中央値は並べて真ん中の値なので80です。」

【例2：概念問題（適切）】
問題文: 「相関係数が r = -0.8 である2つの変数の関係として正しいものはどれか。」
選択肢:
1. 強い正の相関がある
2. 強い負の相関がある ✓（正解）
3. 弱い負の相関がある
4. 相関はない
解説: 「相関係数は-1から1の値を取り、絶対値が1に近いほど相関が強くなります。r = -0.8は絶対値が0.8と1に近く、負の値なので強い負の相関を示します。一方の変数が増加すると他方が減少する関係です。」

# 避けるべき悪い問題の例
【例：曖昧な問題（不適切）】
❌ 問題文: 「データの代表値について正しいものはどれか。」
理由: 何を問うているのか不明確。「正しい」の基準が曖昧。

【例：範囲外の問題（不適切）】  
❌ 問題文（4級で）: 「ベイズの定理を用いて事後確率を計算せよ。」
理由: ベイズの定理は4級の範囲外。

【例：不自然な選択肢（不適切）】
❌ 選択肢: 1. 平均値は76です 2. 平均値は77です 3. バナナ 4. 平均値は78です
理由: 選択肢3が明らかに不自然で、問題の質を損なう。

【問題作成の要件（必須）】
1. 出力形式
   - 各問題は4択形式（選択肢は4つ）
   - 正解は1〜4の整数で指定（correct フィールド）
   - 問題IDは1から順番に付与

2. 難易度と範囲
   - ${request.grade}の難易度に厳密に合わせる
   - 指定された出題内容の範囲内で問題を作成
   - 範囲外の高度な概念や用語は使用しない

3. 問題文の作成
   - 明確で曖昧さのない表現を使用
   - 具体的なシナリオや数値例を含める
   - 専門用語は${request.grade}レベルに適したものを使用
   - 問題文は簡潔にしつつ、必要な情報をすべて含める

4. 選択肢の作成（重要）
   - 正解の選択肢：完全に正しく、疑いの余地がない
   - 誤答の選択肢：もっともらしく、よくある誤解や計算ミスを反映
   - 4つの選択肢は互いに排他的（重複しない）
   - 選択肢の長さや形式をある程度揃える
   - 「すべて正しい」「どれも正しくない」のような選択肢は原則避ける

5. 解説の作成（最重要）
   - なぜその選択肢が正解なのかを明確に説明
   - 誤答の選択肢がなぜ間違いなのかも簡潔に説明
   - 計算問題の場合は計算過程を段階的に示す
   - 概念問題の場合は根拠となる理論や定義を示す
   - 実務での応用例や注意点があれば追記
   - 解説は200〜400文字程度で、丁寧かつ分かりやすく

6. 問題の多様性
   - 計算問題：具体的な数値を使った計算（30〜40%）→ グラフ使用率70%以上
   - 概念問題：定義や特徴の理解を問う（30〜40%）→ グラフ使用率50%以上
   - 応用問題：実際の場面での判断を問う（20〜30%）→ グラフ使用率80%以上
   
   🎯 全体でグラフ使用率60-70%を達成すること
   - 計算問題でもグラフから値を読み取る形式を優先
   - 概念問題でもグラフ例を示すことで理解を深める
   - 応用問題は実データのグラフを使うことが必須

【グラフの表示について】
✅ グラフを表示できます
- 散布図、ヒストグラム、棒グラフ、折れ線グラフが表示可能
- グラフを使う問題では、「下の図を見て」「下のグラフについて」という表現を使ってください
- グラフデータはJSON形式で提供してください（詳細は出力形式を参照）

🎯 グラフ使用の優先順位（積極的にグラフを活用してください）
【必ずグラフを使うべき問題】
- 相関の強さや方向を判断させる問題
- データの分布形状（歪み、対称性）を判断させる問題
- 散布図から相関係数を推定させる問題
- ヒストグラムから平均値と中央値の大小を判断させる問題
- 時系列データの傾向を読み取る問題
- 外れ値の有無を視覚的に判断させる問題

【グラフを使うと効果的な問題】
- 最頻値（モード）を含む階級を特定する問題
- 中央値を含む階級を特定する問題
- データの範囲やばらつきを比較する問題
- 累積度数や相対度数を計算する問題

【グラフが不要な問題（全体の3〜4割のみ）】
- 純粋な定義問題（例：「母集団とは何か」「全数調査の定義」）
- 公式を問う問題（例：「分散の計算式はどれか」）
- 確率の基本計算（例：「コインを3回投げて2回表が出る確率」）
- 統計用語の意味（例：「p値の解釈」）
⚠️ ただし、これらも可能な限りグラフで補足することを検討してください

【グラフを使う問題の具体例（60-70%の問題で使用）】

📊 散布図を使う問題（相関・回帰で100%使用）
- 「下の散布図から相関係数を推定しなさい」
- 「散布図を見て、最も適切な回帰直線を選びなさい」
- 「外れ値を含む散布図で、相関係数への影響を判断」
- 「2つの散布図を比較して、相関の強さを判断」

📊 ヒストグラムを使う問題（度数分布で90%以上使用）
- 「下のヒストグラムから最頻値を含む階級を選びなさい」
- 「ヒストグラムから平均値と中央値の大小関係を判断」
- 「分布の歪みの方向を判断（右歪み/左歪み）」
- 「2つのヒストグラムを比較してばらつきの大小を判断」

📊 折れ線グラフを使う問題（時系列で80%以上使用）
- 「下の折れ線グラフから傾向を読み取る」
- 「季節変動や周期性を判断させる」
- 「移動平均による平滑化の効果を確認」

📊 ヒストグラムを使う問題（度数分布で90%以上使用）
- chartType: "histogram" を使用（"bar"ではない）
- 「下のヒストグラムから最頻値を含む階級を選ぶ」
- 「分布の歪み（右歪み/左歪み）を判断」
- 「平均値と中央値の大小関係を分布形状から判断」
- 「度数が最も多い階級を特定」

📊 箱ひげ図を使う問題（100%使用）
- chartType: "boxplot" を使用
- boxPlotData: {"min": 数値, "q1": 数値, "median": 数値, "q3": 数値, "max": 数値}
- 「下の箱ひげ図から四分位範囲（IQR）を求める」
- 「箱ひげ図から中央値を読み取る」
- 「データの範囲（レンジ）を求める」
- 「複数の箱ひげ図を比較してばらつきを判断」

⚠️ グラフなしでも解ける場合でも、視覚化できるならグラフを追加
  ✅ 推奨：「下のヒストグラムで平均値と中央値を比較」（グラフあり）
  ❌ 避ける：「データ: 1,2,3,4,100の平均値と中央値を比較」（数値のみ）

【問題作成の戦略（ベストプラクティス）】
1. 段階的な難易度設定
   - 最初の2〜3問：基本的な定義や簡単な計算
   - 中間の4〜6問：標準的な問題
   - 最後の2〜3問：やや応用的または複合的な問題

2. 誤答選択肢の設計（学習効果を高める）
   - 計算ミスによる誤答（符号ミス、桁違い、計算順序の誤りなど）
   - 概念の混同（似た用語や手法の取り違え）
   - 部分的に正しいが完全ではない選択肢
   - 直感的には正しそうだが論理的に誤っている選択肢

3. 実践的なシナリオの使用
   - 身近な例：テストの点数、気温、身長体重、売上など
   - 実際の統計検定で出題されそうな状況設定
   - 学習者が理解しやすい具体的なコンテキスト

4. 用語と表記の統一
   - 統計用語は正式な日本語表記を使用
   - 数式は分かりやすく表記（必要に応じて日本語で説明）
   - 略語を使う場合は初出時に正式名称も併記

5. 避けるべきパターン
   × トリッキーな問題（揚げ足取り）
   × 範囲外の高度な内容
   × 曖昧な表現で複数解釈が可能な問題
   × 実務で使われない架空の概念
   × 選択肢が明らかに不自然なもの

【出力形式】
以下のJSON形式で出力してください（JSONのみを出力し、他の文章は含めないでください）：

基本形式（グラフなし）:
[
  {
    "id": 1,
    "question": "問題文",
    "options": ["選択肢1", "選択肢2", "選択肢3", "選択肢4"],
    "correct": 2,
    "explanation": "詳しい解説"
  }
]

グラフ付き形式（散布図の例）:
[
  {
    "id": 2,
    "question": "下の散布図について、2変数の関係を最もよく説明しているのはどれですか。",
    "options": ["強い正の相関", "強い負の相関", "相関なし", "曲線的関係"],
    "correct": 1,
    "explanation": "右上がりの直線状に並んでいるため、強い正の相関があります。",
    "chartType": "scatter",
    "chartData": [
      {"x": 1, "y": 2.1},
      {"x": 2, "y": 4.0},
      {"x": 3, "y": 5.9},
      {"x": 4, "y": 8.1},
      {"x": 5, "y": 10.0}
    ],
    "chartLabels": {"x": "変数X", "y": "変数Y"}
  }
]

グラフ付き形式（ヒストグラム・棒グラフの例）:
[
  {
    "id": 3,
    "question": "下のヒストグラムで、最頻値を含む階級はどれですか。",
    "options": ["10-20点", "20-30点", "30-40点", "40-50点"],
    "correct": 3,
    "explanation": "最も度数が高い（柱が高い）30-40点の階級に最頻値があります。",
    "chartType": "bar",
    "barData": [
      {"name": "0-10", "value": 2},
      {"name": "10-20", "value": 5},
      {"name": "20-30", "value": 8},
      {"name": "30-40", "value": 15},
      {"name": "40-50", "value": 10},
      {"name": "50-60", "value": 6}
    ],
    "chartLabels": {"x": "点数", "y": "度数（人）"}
  }
]

グラフ付き形式（折れ線グラフの例）:
[
  {
    "id": 4,
    "question": "下の折れ線グラフから、どのような傾向が読み取れますか。",
    "options": ["増加傾向", "減少傾向", "変化なし", "周期的変動"],
    "correct": 1,
    "explanation": "時間の経過とともに値が増加しており、明確な増加傾向が見られます。",
    "chartType": "line",
    "chartData": [
      {"name": "1月", "value": 10},
      {"name": "2月", "value": 15},
      {"name": "3月", "value": 22},
      {"name": "4月", "value": 28},
      {"name": "5月", "value": 35}
    ],
    "chartLabels": {"x": "月", "y": "売上（万円）"}
  }
]

グラフ付き形式（ヒストグラムの例）:
[
  {
    "id": 5,
    "question": "下のヒストグラムから、このデータの分布形状について最も適切に説明しているのはどれですか。",
    "options": ["左右対称である", "右に歪んでいる", "左に歪んでいる", "二峰性である"],
    "correct": 2,
    "explanation": "度数の最大値が左側にあり、右側に長い裾を引いているため、右に歪んだ分布（正の歪み）です。",
    "chartType": "histogram",
    "barData": [
      {"name": "0-10", "value": 15},
      {"name": "10-20", "value": 25},
      {"name": "20-30", "value": 20},
      {"name": "30-40", "value": 12},
      {"name": "40-50", "value": 6},
      {"name": "50-60", "value": 2}
    ],
    "chartLabels": {"x": "階級（点）", "y": "度数（人）"}
  }
]

グラフ付き形式（箱ひげ図の例）:
[
  {
    "id": 6,
    "question": "下の箱ひげ図から四分位範囲（IQR）を求めなさい。",
    "options": ["10", "15", "20", "25"],
    "correct": 3,
    "explanation": "四分位範囲（IQR）は第3四分位数Q3から第1四分位数Q1を引いた値です。75 - 55 = 20となります。",
    "chartType": "boxplot",
    "boxPlotData": {
      "min": 40,
      "q1": 55,
      "median": 65,
      "q3": 75,
      "max": 90
    }
  }
]

【グラフフィールドの説明】
- chartType: "scatter" | "bar" | "line" | "histogram" | "boxplot" のいずれか（グラフ不要の場合は省略）
- chartData: scatter/lineの場合 → [{"x": 数値, "y": 数値}, ...] または [{"name": "文字列", "value": 数値}, ...]
- barData: bar/histogramの場合 → [{"name": "文字列", "value": 数値}, ...]
- boxPlotData: boxplotの場合 → {"min": 数値, "q1": 数値, "median": 数値, "q3": 数値, "max": 数値}
- chartLabels: {"x": "X軸ラベル", "y": "Y軸ラベル"}（boxplot以外）

【グラフデータ生成のガイドライン】
1. データポイント数
   - 散布図: 5〜12点程度
   - ヒストグラム: 6〜10階級程度
   - 折れ線グラフ: 5〜10点程度
   - 箱ひげ図: min, q1, median, q3, maxの5つの値

2. データの妥当性
   - 相関がある散布図: データが直線状に並ぶ（y ≈ ax + b + 少しのばらつき）
   - 相関がない散布図: データがランダムに散らばる
   - ヒストグラムの度数: 1〜20程度の整数
   - 箱ひげ図: min < q1 < median < q3 < max の関係を必ず守る

3. グラフを含める問題の割合 🎯 実際の試験レベル（6〜7割）
   - セクション問題（10問想定）: 6〜7問（60-70%）
   - 5問なら3〜4問、15問なら9〜11問を目安に
   - 📊 実際の統計検定試験では6〜7割の問題でグラフが使われています
   - グラフで視覚的に示せる問題は必ずグラフを使用
   - 特に以下のトピックでは必須：
     * 相関・散布図（100%グラフ使用）
     * 回帰分析（100%グラフ使用）
     * ヒストグラム・度数分布（90%以上グラフ使用）
     * 箱ひげ図（100%グラフ使用）
     * 時系列データ（80%以上グラフ使用）
     * データの分布形状（90%以上グラフ使用）
     * 代表値の比較（70%以上グラフ使用）

【重要】
- すべてのフィールド名は必ず小文字で記述してください
- chartDataとbarDataを同時に含めないでください
- グラフなしの問題では、chartType等のフィールドを含めないでください
- ヒストグラムは chartType: "histogram" を使用（"bar"と混同しない）
- 箱ひげ図は chartType: "boxplot" を使用し、boxPlotData を必ず含める
- barData は "bar" と "histogram" で共用
- boxPlotData は "boxplot" 専用で、{"min": 数値, "q1": 数値, "median": 数値, "q3": 数値, "max": 数値} の形式

【選択肢作成の注意点 - 最重要】
⚠️ 確率・分数の選択肢では、必ず既約分数（約分済み）にしてください

🚨 絶対に避けるべき重複パターン：
- 「1/4」と「13/52」は同じ値 → 「1/4」のみ使用
- 「1/2」と「2/4」「3/6」「50/100」は同じ値 → 「1/2」のみ使用
- 「1/3」と「2/6」「3/9」は同じ値 → 「1/3」のみ使用
- 「4/25」と「16/100」は同じ値 → 「4/25」のみ使用
- 「5/14」と「10/28」は同じ値 → 「5/14」のみ使用
- 「1/25」と「4/100」は同じ値 → 「1/25」のみ使用

✅ 選択肢作成の手順：
1. まず正解の分数を既約分数にする
2. 誤答の分数も既約分数にする
3. すべての選択肢を小数に変換して重複がないか確認する
4. 重複があれば別の値に変更する

❌ 絶対NG：
- 同じ値を異なる形で表現（例：1/2と2/4）
- 約分前の分数と約分後の分数の混在（例：4/25と16/100）

すべての選択肢は明確に異なる値である必要があります

【🚨 グラフ参照の厳格ルール - 最優先事項 🚨】
⚠️ このルールは絶対に守ってください。違反は重大なエラーです。

1️⃣ グラフ参照表現を使った場合は**必ず**グラフデータを含める
   禁止表現（これらを使う場合は必ずchartType、chartData/barData、chartLabelsを含める）:
   - 「下のグラフ」「次のグラフ」「以下のグラフ」
   - 「下の図」「次の図」「以下の図」
   - 「下の散布図」「次の散布図」
   - 「下のヒストグラム」「次のヒストグラム」
   - 「下の折れ線グラフ」「次の折れ線グラフ」
   - 「下の棒グラフ」「次の棒グラフ」

2️⃣ グラフデータがない問題では、上記の表現を**絶対に使わない**
   ✅ 正しい表現: 「相関係数が0.9のとき...」「度数が最も多い階級を選びなさい」
   ❌ 間違い: 「次のグラフで相関係数が...」（グラフデータなし）

3️⃣ 問題文作成時のチェックリスト
   - 問題文に「下の」「次の」が含まれる → chartTypeを確認
   - chartTypeがある → 問題文に「下の○○」を含める
   - chartTypeがない → 問題文に「下の○○」を含めない

4️⃣ 整合性の例
   ✅ 正しい例:
   {
     "question": "下の散布図について、相関係数の値として最も適切なものはどれですか。",
     "chartType": "scatter",
     "chartData": [...]
   }
   
   ❌ 間違いの例:
   {
     "question": "次のグラフで、相関係数として最も適切なものはどれですか。",
     // chartTypeがない！これは絶対にNG！
   }

⚠️ この整合性チェックは問題生成の最優先事項です。必ず守ってください。`;
  } else {
    const topics = request.grade === '4級' ? grade4Topics : grade3Topics;
    prompt = `あなたは統計検定の問題作成の専門家です。以下の条件で模擬試験問題を作成してください。

【条件】
- 級: ${request.grade}
- 試験形式: 模擬試験（全範囲から出題）
- 問題数: ${request.count}問

${topics}

【要件】
1. 各問題は4択形式
2. 正解は1〜4の数字で指定
3. 詳しい解説を含める
4. ${request.grade}の難易度に適した問題
5. 実際の統計検定の出題形式に近い問題
6. 全範囲からバランスよく出題（特定の分野に偏らない）
7. 過去問の出題傾向を考慮した問題

【${request.grade}の特徴】
${request.grade === '4級' 
  ? '- グラフ読解問題を15-20%程度含める（ヒストグラム、散布図など）\n- 度数分布表の問題を15-20%程度含める\n- 確率の基本問題を10%程度含める\n- 具体的な数値を使った計算問題を多めに'
  : '- 推測統計の問題を25-30%程度含める\n- 相関・回帰分析を15-20%程度含める（散布図を含む）\n- 仮説検定の問題を20-25%程度含める\n- 概念理解を問う問題と計算問題をバランスよく'
}

【出力形式】
以下のJSON形式で出力してください（JSONのみを出力し、他の文章は含めないでください）：

基本形式（グラフなし）:
[
  {
    "id": 1,
    "question": "問題文",
    "options": ["選択肢1", "選択肢2", "選択肢3", "選択肢4"],
    "correct": 2,
    "explanation": "詳しい解説"
  }
]

グラフ付き形式（散布図の例）:
[
  {
    "id": 2,
    "question": "下の散布図について、2変数の関係を最もよく説明しているのはどれですか。",
    "options": ["強い正の相関", "強い負の相関", "相関なし", "曲線的関係"],
    "correct": 1,
    "explanation": "右上がりの直線状に並んでいるため、強い正の相関があります。",
    "chartType": "scatter",
    "chartData": [
      {"x": 1, "y": 2.1},
      {"x": 2, "y": 4.0},
      {"x": 3, "y": 5.9},
      {"x": 4, "y": 8.1},
      {"x": 5, "y": 10.0}
    ],
    "chartLabels": {"x": "変数X", "y": "変数Y"}
  }
]

グラフ付き形式（ヒストグラム・棒グラフの例）:
[
  {
    "id": 3,
    "question": "下のヒストグラムで、最頻値を含む階級はどれですか。",
    "options": ["10-20点", "20-30点", "30-40点", "40-50点"],
    "correct": 3,
    "explanation": "最も度数が高い（柱が高い）30-40点の階級に最頻値があります。",
    "chartType": "bar",
    "barData": [
      {"name": "0-10", "value": 2},
      {"name": "10-20", "value": 5},
      {"name": "20-30", "value": 8},
      {"name": "30-40", "value": 15},
      {"name": "40-50", "value": 10},
      {"name": "50-60", "value": 6}
    ],
    "chartLabels": {"x": "点数", "y": "度数（人）"}
  }
]

グラフ付き形式（折れ線グラフの例）:
[
  {
    "id": 4,
    "question": "下の折れ線グラフから、どのような傾向が読み取れますか。",
    "options": ["増加傾向", "減少傾向", "変化なし", "周期的変動"],
    "correct": 1,
    "explanation": "時間の経過とともに値が増加しており、明確な増加傾向が見られます。",
    "chartType": "line",
    "chartData": [
      {"name": "1月", "value": 10},
      {"name": "2月", "value": 15},
      {"name": "3月", "value": 22},
      {"name": "4月", "value": 28},
      {"name": "5月", "value": 35}
    ],
    "chartLabels": {"x": "月", "y": "売上（万円）"}
  }
]

グラフ付き形式（ヒストグラムの例）:
[
  {
    "id": 5,
    "question": "下のヒストグラムから、このデータの分布形状について最も適切に説明しているのはどれですか。",
    "options": ["左右対称である", "右に歪んでいる", "左に歪んでいる", "二峰性である"],
    "correct": 2,
    "explanation": "度数の最大値が左側にあり、右側に長い裾を引いているため、右に歪んだ分布（正の歪み）です。",
    "chartType": "histogram",
    "barData": [
      {"name": "0-10", "value": 15},
      {"name": "10-20", "value": 25},
      {"name": "20-30", "value": 20},
      {"name": "30-40", "value": 12},
      {"name": "40-50", "value": 6},
      {"name": "50-60", "value": 2}
    ],
    "chartLabels": {"x": "階級（点）", "y": "度数（人）"}
  }
]

グラフ付き形式（箱ひげ図の例）:
[
  {
    "id": 6,
    "question": "下の箱ひげ図から四分位範囲（IQR）を求めなさい。",
    "options": ["10", "15", "20", "25"],
    "correct": 3,
    "explanation": "四分位範囲（IQR）は第3四分位数Q3から第1四分位数Q1を引いた値です。75 - 55 = 20となります。",
    "chartType": "boxplot",
    "boxPlotData": {
      "min": 40,
      "q1": 55,
      "median": 65,
      "q3": 75,
      "max": 90
    }
  }
]

【グラフフィールドの説明】
- chartType: "scatter" | "bar" | "line" | "histogram" | "boxplot" のいずれか（グラフ不要の場合は省略）
- chartData: scatter/lineの場合 → [{"x": 数値, "y": 数値}, ...] または [{"name": "文字列", "value": 数値}, ...]
- barData: bar/histogramの場合 → [{"name": "文字列", "value": 数値}, ...]
- boxPlotData: boxplotの場合 → {"min": 数値, "q1": 数値, "median": 数値, "q3": 数値, "max": 数値}
- chartLabels: {"x": "X軸ラベル", "y": "Y軸ラベル"}（boxplot以外）

【グラフデータ生成のガイドライン】
1. データポイント数
   - 散布図: 5〜12点程度
   - ヒストグラム: 6〜10階級程度
   - 折れ線グラフ: 5〜10点程度
   - 箱ひげ図: min, q1, median, q3, maxの5つの値

2. データの妥当性
   - 相関がある散布図: データが直線状に並ぶ（y ≈ ax + b + 少しのばらつき）
   - 相関がない散布図: データがランダムに散らばる
   - ヒストグラムの度数: 1〜20程度の整数
   - 箱ひげ図: min < q1 < median < q3 < max の関係を必ず守る

3. グラフを含める問題の割合 🎯 実際の試験レベル（6〜7割）
   - 模擬試験（30問）: 18〜21問（60-70%）
   - 📊 実際の統計検定試験では6〜7割の問題でグラフが使われています
   - グラフで視覚的に示せる問題は必ずグラフを使用
   - 全範囲に適用可能（散布図、ヒストグラム、折れ線グラフなど）
   - 特にグラフを活用すべき分野（高優先度）：
     * 記述統計（分布、代表値、ばらつき）→ 90%以上
     * 相関・回帰 → 100%
     * データの可視化 → 100%
     * 時系列分析 → 80%以上
     * 確率分布の形状 → 70%以上

【重要】
- すべてのフィールド名は必ず小文字で記述してください
- chartDataとbarDataを同時に含めないでください
- グラフなしの問題では、chartType等のフィールドを含めないでください
- ヒストグラムは chartType: "histogram" を使用（"bar"と混同しない）
- 箱ひげ図は chartType: "boxplot" を使用し、boxPlotData を必ず含める
- barData は "bar" と "histogram" で共用
- boxPlotData は "boxplot" 専用で、{"min": 数値, "q1": 数値, "median": 数値, "q3": 数値, "max": 数値} の形式

【選択肢作成の注意点 - 最重要】
⚠️ 確率・分数の選択肢では、必ず既約分数（約分済み）にしてください

🚨 絶対に避けるべき重複パターン：
- 「1/4」と「13/52」は同じ値 → 「1/4」のみ使用
- 「1/2」と「2/4」「3/6」「50/100」は同じ値 → 「1/2」のみ使用
- 「1/3」と「2/6」「3/9」は同じ値 → 「1/3」のみ使用
- 「4/25」と「16/100」は同じ値 → 「4/25」のみ使用
- 「5/14」と「10/28」は同じ値 → 「5/14」のみ使用
- 「1/25」と「4/100」は同じ値 → 「1/25」のみ使用

✅ 選択肢作成の手順：
1. まず正解の分数を既約分数にする
2. 誤答の分数も既約分数にする
3. すべての選択肢を小数に変換して重複がないか確認する
4. 重複があれば別の値に変更する

❌ 絶対NG：
- 同じ値を異なる形で表現（例：1/2と2/4）
- 約分前の分数と約分後の分数の混在（例：4/25と16/100）

すべての選択肢は明確に異なる値である必要があります

【🚨 グラフ参照の厳格ルール - 最優先事項 🚨】
⚠️ このルールは絶対に守ってください。違反は重大なエラーです。

1️⃣ グラフ参照表現を使った場合は**必ず**グラフデータを含める
   禁止表現（これらを使う場合は必ずchartType、chartData/barData、chartLabelsを含める）:
   - 「下のグラフ」「次のグラフ」「以下のグラフ」
   - 「下の図」「次の図」「以下の図」
   - 「下の散布図」「次の散布図」
   - 「下のヒストグラム」「次のヒストグラム」
   - 「下の折れ線グラフ」「次の折れ線グラフ」
   - 「下の棒グラフ」「次の棒グラフ」

2️⃣ グラフデータがない問題では、上記の表現を**絶対に使わない**
   ✅ 正しい表現: 「相関係数が0.9のとき...」「度数が最も多い階級を選びなさい」
   ❌ 間違い: 「次のグラフで相関係数が...」（グラフデータなし）

3️⃣ 問題文作成時のチェックリスト
   - 問題文に「下の」「次の」が含まれる → chartTypeを確認
   - chartTypeがある → 問題文に「下の○○」を含める
   - chartTypeがない → 問題文に「下の○○」を含めない

4️⃣ 整合性の例
   ✅ 正しい例:
   {
     "question": "下の散布図について、相関係数の値として最も適切なものはどれですか。",
     "chartType": "scatter",
     "chartData": [...]
   }
   
   ❌ 間違いの例:
   {
     "question": "次のグラフで、相関係数として最も適切なものはどれですか。",
     // chartTypeがない！これは絶対にNG！
   }

⚠️ この整合性チェックは問題生成の最優先事項です。必ず守ってください。`;
  }

  try {
    validateRequest(request);

    const generateWithRetry = async (): Promise<GeneratedQuestion[]> => {
      try {
        const result = await withTimeout(
          model.generateContent(prompt),
          API_TIMEOUT
        );

        const response = result.response;
        
        if (!response) {
          throw new APIError('APIからのレスポンスが空です。');
        }

        let text: string;
        try {
          text = response.text();
        } catch (textError) {
          console.error('レスポンステキスト取得エラー:', textError);
          throw new APIError('APIレスポンスからテキストを取得できませんでした。');
        }

        if (!text || text.trim().length === 0) {
          throw new APIError('APIから空のレスポンスが返されました。');
        }

        const jsonMatch = text.match(/\[[\s\S]*\]/);
        if (!jsonMatch) {
          console.error('JSONが見つかりません。レスポンス:', text.substring(0, 500));
          throw new ValidationError(
            'AIの応答からJSON形式のデータを抽出できませんでした。再度お試しください。'
          );
        }

        let parsedData: any;
        try {
          const cleanedJson = jsonMatch[0].replace(/[\u0000-\u0008\u000B-\u000C\u000E-\u001F\u007F-\u009F]/g, ' ');
          parsedData = JSON.parse(cleanedJson);
        } catch (parseError) {
          console.error('JSONパースエラー:', parseError);
          console.error('パース対象:', jsonMatch[0].substring(0, 500));
          throw new ValidationError('JSONデータの解析に失敗しました。形式が不正です。');
        }

        if (!Array.isArray(parsedData)) {
          throw new ValidationError('AIの応答が配列形式ではありません。');
        }

        if (parsedData.length === 0) {
          throw new ValidationError('AIが問題を生成しませんでした。');
        }

        if (parsedData.length !== request.count) {
          console.warn(
            `要求された問題数（${request.count}）と生成された問題数（${parsedData.length}）が一致しません。`
          );
        }

        const validatedQuestions: GeneratedQuestion[] = [];
        for (let i = 0; i < parsedData.length; i++) {
          try {
            const validated = validateQuestion(parsedData[i], i);
            
            validated.question = sanitizeText(validated.question);
            validated.options = validated.options.map(opt => sanitizeText(opt));
            validated.explanation = sanitizeText(validated.explanation);
            
            ensureGraphData(validated);
            
            validatedQuestions.push(validated);
          } catch (validationError) {
            console.error(`問題${i + 1}のバリデーションエラー:`, validationError);
            throw validationError;
          }
        }

        if (validatedQuestions.length < Math.min(3, request.count)) {
          throw new ValidationError(
            `有効な問題が不足しています（${validatedQuestions.length}/${request.count}）。`
          );
        }

        return validatedQuestions.slice(0, request.count);

      } catch (error) {
        if (error instanceof ValidationError || error instanceof TimeoutError || error instanceof RateLimitError) {
          throw error;
        }

        if (error instanceof Error) {
          const errorMessage = error.message.toLowerCase();
          
          if (errorMessage.includes('429') || errorMessage.includes('rate limit') || errorMessage.includes('too many requests')) {
            const retryAfter = 60000;
            throw new RateLimitError(
              'APIのレート制限に達しました。1分後に自動的にリトライします。', 
              retryAfter
            );
          }
          
          if (errorMessage.includes('quota exceeded') || errorMessage.includes('quota')) {
            throw new RateLimitError(
              'API使用量の上限に達しました。しばらく待ってから再試行してください。',
              300000
            );
          }
          
          if (errorMessage.includes('api key') || errorMessage.includes('unauthorized')) {
            throw new APIError('APIキーが無効です。設定を確認してください。', 401);
          }
          
          if (errorMessage.includes('network') || errorMessage.includes('fetch')) {
            throw new APIError('ネットワークエラーが発生しました。インターネット接続を確認してください。');
          }
        }

        throw new APIError(
          `問題生成中にエラーが発生しました: ${error instanceof Error ? error.message : '不明なエラー'}`
        );
      }
    };

    return await retryWithBackoff(generateWithRetry);

  } catch (error) {
    console.error('問題生成の最終エラー:', error);

    if (error instanceof ValidationError) {
      throw error;
    }
    if (error instanceof RateLimitError) {
      const waitMinutes = Math.ceil(error.retryAfter / 60000);
      throw new Error(
        `APIのレート制限に達しました。${waitMinutes}分ほど待ってから再試行してください。`
      );
    }
    if (error instanceof TimeoutError) {
      throw new Error(
        '問題の生成に時間がかかりすぎています。問題数を減らすか、しばらく待ってから再試行してください。'
      );
    }
    if (error instanceof APIError) {
      throw new Error(error.message);
    }

    throw new Error(
      '問題の生成に失敗しました。時間をおいて再度お試しいただくか、問題数を減らしてみてください。'
    );
  }
}

